import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Location } from '@angular/common';
import { OrderRequestService, PartsTestListResponse, DataTable } from 'src/app/core/services/order-request.service';
import { 
  OrderRequestDto, 
  SaveUpdateOrderRequestRequest, 
  SaveUpdateOrderRequestResponse,
  ORDER_REQUEST_STATUS_OPTIONS,
  ORDER_REQUEST_TYPE_OPTIONS,
  OrderRequestStatusOption,
  OrderRequestTypeOption,
  AutoGeneratedId,
  OrderRequestAttachment,
  UploadedFileInfo
} from 'src/app/core/model/order-request.model';
import { AuthService } from 'src/app/modules/auth/services/auth.service';

@Component({
  selector: 'app-order-request',
  templateUrl: './order-request.component.html',
  styleUrls: ['./order-request.component.scss']
})
export class OrderRequestComponent implements OnInit {
  maxRowIndex: number | null = null;
  isLoading = false;
  error: string | null = null;
  
  // Parts test list related properties
  partsTestData: PartsTestListResponse | null = null;
  isLoadingPartsTest = false;
  partsTestError: string | null = null;
  selectedRowIndex: number = 1;
  selectedSource: string = 'OrderRequest';
  availableSources = ['OrderRequest', 'PartsTest', 'UnitTest', 'Other'];
  
  // Delete functionality
  isDeleting = false;
  deleteError: string | null = null;
  deleteSuccess: string | null = null;

  // Form functionality
  orderRequestForm: FormGroup;
  isFormSubmitting = false;
  formError: string | null = null;
  formSuccess: string | null = null;
  isEditMode = false;
  currentUser: any;
  
  // Auto Generated ID (matching legacy)
  autoGeneratedId: AutoGeneratedId | null = null;
  
  // File attachment functionality
  selectedFiles: File[] = [];
  attachments: OrderRequestAttachment[] = [];
  isUploadingFiles = false;
  
  // File upload restrictions (matching legacy system)
  private readonly ALLOWED_FILE_TYPES = ['jpg', 'gif', 'doc', 'bmp', 'xls', 'png', 'txt', 'xlsx', 'docx', 'pdf', 'jpeg'];
  private readonly MAX_FILE_SIZE_MB = 5;
  private readonly MAX_FILE_SIZE_BYTES = this.MAX_FILE_SIZE_MB * 1024 * 1024;
  
  // Dropdown options (matching legacy)
  statusOptions: OrderRequestStatusOption[] = ORDER_REQUEST_STATUS_OPTIONS;
  departmentOptions: OrderRequestTypeOption[] = ORDER_REQUEST_TYPE_OPTIONS;

  constructor(
    private orderRequestService: OrderRequestService,
    private fb: FormBuilder,
    private authService: AuthService,
    private location: Location
  ) {
    this.initializeForm();
  }

  ngOnInit(): void {
    this.currentUser = this.authService.currentUserValue;
    
    // Set the current user as the lastModifiedBy after user is loaded
    if (this.currentUser?.userName) {
      this.orderRequestForm.patchValue({
        lastModifiedBy: this.currentUser.userName
      });
    }
    
    this.generateAutoId();
    this.loadMaxOrderRequestRowIndex();
  }

  /**
   * Initialize the reactive form (matching legacy form fields)
   */
  initializeForm(): void {
    this.orderRequestForm = this.fb.group({
      rowIndex: [0],
      orderType: ['', [Validators.required]], // Department - required, must not be "PS" or empty
      requester: ['', [Validators.required]], // Required - cannot be empty or null
      dcgPartNo: [''], // DCG P/N# - optional
      manufPartNo: ['', [Validators.required]], // Manuf P/N# - required, cannot be empty or null
      vendor: [''], // Vendor - optional
      qtyNeeded: [null, [Validators.required]], // Qty Needed - required, must be numeric integer
      poNumber: [''], // PO - optional
      orderDate: [null, [Validators.required]], // Order Date - required, cannot be empty
      arriveDate: [null], // Arrive Date - optional
      notes: [''], // Notes - optional
      status: ['NEW'], // Default to 'NEW' status - optional
      lastModifiedBy: ['', [Validators.required]]
    });

    // Set the current user as the lastModifiedBy default value
    if (this.currentUser?.userName) {
      this.orderRequestForm.patchValue({
        lastModifiedBy: this.currentUser.userName
      });
    }
  }

  /**
   * Generate auto ID similar to legacy format (YYYY MM DD ###)
   */
  generateAutoId(): void {
    const now = new Date();
    this.autoGeneratedId = {
      year: now.getFullYear().toString(),
      month: (now.getMonth() + 1).toString().padStart(2, '0'),
      day: now.getDate().toString().padStart(2, '0'),
      id: Math.floor(Math.random() * 1000).toString().padStart(3, '0') // Random 3-digit number for demo
    };
  }

  /**
   * Load the maximum Order Request row index
   */
  loadMaxOrderRequestRowIndex(): void {
    this.isLoading = true;
    this.error = null;

    this.orderRequestService.getMaxOrderRequestRowIndex().subscribe({
      next: (data: number) => {
        this.maxRowIndex = data;
        this.selectedRowIndex = Math.min(1, data || 1); // Set default row index
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading max order request row index:', error);
        this.error = 'Failed to load Order Request data. Please try again.';
        this.isLoading = false;
      }
    });
  }

  /**
   * Load parts test list data
   */
  loadPartsTestList(): void {
    if (this.selectedRowIndex < 1) {
      this.partsTestError = 'Please enter a valid row index (minimum 1)';
      return;
    }

    if (this.maxRowIndex && this.selectedRowIndex > this.maxRowIndex) {
      this.partsTestError = `Row index cannot exceed maximum value of ${this.maxRowIndex}`;
      return;
    }

    this.isLoadingPartsTest = true;
    this.partsTestError = null;
    this.partsTestData = null;

    this.orderRequestService.getPartsTestList(this.selectedRowIndex, this.selectedSource).subscribe({
      next: (data: PartsTestListResponse) => {
        this.partsTestData = data;
        this.isLoadingPartsTest = false;
        
        if (data.ErrorMessage) {
          this.partsTestError = data.ErrorMessage;
        }
      },
      error: (error) => {
        console.error('Error loading parts test list:', error);
        this.partsTestError = 'Failed to load Parts Test List data. Please try again.';
        this.isLoadingPartsTest = false;
      }
    });
  }

  /**
   * Refresh the data
   */
  refreshData(): void {
    this.loadMaxOrderRequestRowIndex();
    if (this.partsTestData) {
      this.loadPartsTestList();
    }
  }

  /**
   * Clear parts test data
   */
  clearPartsTestData(): void {
    this.partsTestData = null;
    this.partsTestError = null;
    this.deleteError = null;
    this.deleteSuccess = null;
  }

  /**
   * Delete parts test list data
   */
  deletePartsTestList(): void {
    if (this.selectedRowIndex < 1) {
      this.deleteError = 'Please enter a valid row index (minimum 1)';
      return;
    }

    if (this.maxRowIndex && this.selectedRowIndex > this.maxRowIndex) {
      this.deleteError = `Row index cannot exceed maximum value of ${this.maxRowIndex}`;
      return;
    }

    // Confirm deletion
    if (!confirm(`Are you sure you want to delete parts test list for Row Index ${this.selectedRowIndex} and Source ${this.selectedSource}?`)) {
      return;
    }

    this.isDeleting = true;
    this.deleteError = null;
    this.deleteSuccess = null;

    this.orderRequestService.deletePartsTestList(this.selectedRowIndex, this.selectedSource).subscribe({
      next: (response: {message: string}) => {
        this.deleteSuccess = response.message || 'Parts test list deleted successfully';
        this.isDeleting = false;
        
        // Clear current data after successful deletion
        this.partsTestData = null;
        
        // Auto-hide success message after 5 seconds
        setTimeout(() => {
          this.deleteSuccess = null;
        }, 5000);
      },
      error: (error) => {
        console.error('Error deleting parts test list:', error);
        this.deleteError = 'Failed to delete Parts Test List data. Please try again.';
        this.isDeleting = false;
      }
    });
  }

  /**
   * Check if a table has data
   */
  hasTableData(table: DataTable): boolean {
    return table && table.Rows && table.Rows.length > 0;
  }

  /**
   * Get display value for table cell
   */
  getCellValue(value: any): string {
    if (value === null || value === undefined) {
      return '';
    }
    return value.toString();
  }

  /**
   * Get current date and time as a formatted string
   */
  getCurrentDateTime(): string {
    return new Date().toLocaleString();
  }

  /**
   * Reset the form to create a new order request
   */
  resetForm(): void {
    this.isEditMode = false;
    this.formError = null;
    this.formSuccess = null;
    this.selectedFiles = [];
    this.attachments = [];
    this.generateAutoId(); // Generate new auto ID
    this.orderRequestForm.reset({
      rowIndex: 0,
      status: 'NEW',
      lastModifiedBy: this.currentUser?.userName || ''
    });
  }

  /**
   * Handle file selection for attachments (with validation matching legacy system)
   */
  onFileSelected(event: any): void {
    const files: FileList = event.target.files;
    if (files && files.length > 0) {
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        // Validate file type
        if (!this.isValidFileType(file.name)) {
          this.formError = `Invalid file format. File must be of format ${this.ALLOWED_FILE_TYPES.join(',')}`;
          continue;
        }
        
        // Validate file size
        if (file.size > this.MAX_FILE_SIZE_BYTES) {
          this.formError = `File size exceeds ${this.MAX_FILE_SIZE_MB}MB limit. Please select a smaller file.`;
          continue;
        }
        
        // Check for duplicates
        if (!this.selectedFiles.find(f => f.name === file.name)) {
          this.selectedFiles.push(file);
          this.attachments.push({
            name: file.name,
            creationTime: new Date(),
            fullName: file.name,
            size: file.size
          });
          
          // Clear any previous errors if file is valid
          this.formError = null;
        }
      }
    }
    
    // Reset the input to allow selecting the same file again if needed
    event.target.value = '';
  }

  /**
   * Remove an attachment
   */
  removeAttachment(index: number): void {
    this.selectedFiles.splice(index, 1);
    this.attachments.splice(index, 1);
  }

  /**
   * Validate file type (matching legacy IsValidFile method)
   */
  private isValidFileType(fileName: string): boolean {
    const fileExtension = this.getFileExtension(fileName);
    return this.ALLOWED_FILE_TYPES.some(allowedType => 
      allowedType.toLowerCase() === fileExtension.toLowerCase()
    );
  }

  /**
   * Get file extension (matching legacy GetFileExtension method)
   */
  private getFileExtension(fileName: string): string {
    const lastDotIndex = fileName.lastIndexOf('.');
    if (lastDotIndex === -1) {
      return '';
    }
    return fileName.substring(lastDotIndex + 1);
  }

  /**
   * Get file size in readable format
   */
  getFileSizeFormatted(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * Load an existing order request for editing (placeholder for future implementation)
   */
  loadOrderRequestForEdit(rowIndex: number): void {
    // This would require a new API endpoint to get order request by row index
    // For now, we'll just set the form to edit mode and populate the row index
    this.isEditMode = true;
    this.orderRequestForm.patchValue({
      rowIndex: rowIndex
    });
  }

  /**
   * Save or update the order request (with validation matching legacy)
   */
  saveOrderRequest(): void {
    // Custom validation matching legacy JavaScript validation
    if (!this.validateForm()) {
      return;
    }

    this.isFormSubmitting = true;
    this.isLoading = true;
    this.formError = null;
    this.formSuccess = null;

    const formValue = this.orderRequestForm.value;
    
    // Convert form data to the API request format
    const orderRequest: SaveUpdateOrderRequestRequest = {
      rowIndex: formValue.rowIndex || 0,
      orderType: formValue.orderType || null,
      requester: formValue.requester || null,
      dcgPartNo: formValue.dcgPartNo || null,
      manufPartNo: formValue.manufPartNo || null,
      vendor: formValue.vendor || null,
      qtyNeeded: formValue.qtyNeeded || null,
      poNumber: formValue.poNumber || null,
      orderDate: formValue.orderDate || null,
      arriveDate: formValue.arriveDate || null,
      notes: formValue.notes || null,
      status: formValue.status || null,
      lastModifiedBy: formValue.lastModifiedBy || this.currentUser?.userName || 'System'
    };

    // Check if we have files to upload
    if (this.selectedFiles.length > 0) {
      // Use the file upload endpoint
      this.orderRequestService.saveUpdateOrderRequestWithFiles(orderRequest, this.selectedFiles).subscribe({
        next: (response: any) => {
          let successMessage = response.message || 'Order request saved successfully';
          
          // Handle file upload results from new backend structure
          if (response.fileResults && response.fileResults.length > 0) {
            const successfulUploads = response.fileResults.filter((f: any) => f.success === true).length;
            const failedUploads = response.fileResults.filter((f: any) => f.success === false).length;
            
            if (failedUploads > 0) {
              // Show failed uploads in error message
              const failedFiles = response.fileResults.filter((f: any) => f.success === false);
              const errorMessages = failedFiles.map((f: any) => `${f.fileName}: ${f.errorMessage}`).join('; ');
              this.formError = `Some files failed to upload: ${errorMessages}`;
            }
            
            // Log file details for debugging
            console.log('File upload results:', response.fileResults);
          }
          
          this.formSuccess = successMessage;
          this.isFormSubmitting = false;
          this.isLoading = false;
          
          // Update the form with the returned row index if it was a new record
          if (orderRequest.rowIndex === 0) {
            this.orderRequestForm.patchValue({
              rowIndex: response.rowIndex
            });
            this.isEditMode = true;
          }
          
          // Clear selected files after successful upload
          this.selectedFiles = [];
          this.attachments = [];
          
          // Refresh the max row index
          this.loadMaxOrderRequestRowIndex();
          
          // Auto-hide success message after 5 seconds
          setTimeout(() => {
            this.formSuccess = null;
          }, 5000);
        },
        error: (error) => {
          console.error('Error saving order request with files:', error);
          this.formError = error.error?.message || 'Failed to save order request with files. Please try again.';
          this.isFormSubmitting = false;
          this.isLoading = false;
        }
      });
    } else {
      // No files, use the regular endpoint
      this.orderRequestService.saveUpdateOrderRequest(orderRequest).subscribe({
        next: (response: any) => {
          this.formSuccess = response.message || 'Order request saved successfully';
          this.isFormSubmitting = false;
          this.isLoading = false;
          
          // Update the form with the returned row index if it was a new record
          if (orderRequest.rowIndex === 0) {
            this.orderRequestForm.patchValue({
              rowIndex: response.rowIndex
            });
            this.isEditMode = true;
          }
          
          // Refresh the max row index
          this.loadMaxOrderRequestRowIndex();
          
          // Auto-hide success message after 5 seconds
          setTimeout(() => {
            this.formSuccess = null;
          }, 5000);
        },
        error: (error) => {
          console.error('Error saving order request:', error);
          this.formError = error.error?.message || 'Failed to save order request. Please try again.';
          this.isFormSubmitting = false;
          this.isLoading = false;
        }
      });
    }
  }

  /**
   * Custom validation matching legacy JavaScript validation
   */
  private validateForm(): boolean {
    const formValue = this.orderRequestForm.value;

    // Department validation (matches legacy - must not be "PS" or empty)
    if (!formValue.orderType || formValue.orderType === '' || formValue.orderType === 'PS') {
      this.formError = "Please select 'Type' and resave your entry.";
      this.orderRequestForm.get('orderType')?.markAsTouched();
      return false;
    }

    // Requester validation (cannot be empty or null)
    if (!formValue.requester || formValue.requester.trim() === '') {
      this.formError = "Please enter 'Requester' and resave your Unit.";
      this.orderRequestForm.get('requester')?.markAsTouched();
      return false;
    }

    // Manufacturer Part No validation (cannot be empty or null)
    if (!formValue.manufPartNo || formValue.manufPartNo.trim() === '') {
      this.formError = "Please enter 'Manuf PNo' and resave your Unit.";
      this.orderRequestForm.get('manufPartNo')?.markAsTouched();
      return false;
    }

    // Quantity validation (cannot be empty and must be numeric integers only)
    if (!formValue.qtyNeeded) {
      this.formError = "Please enter 'Quantity' and resave your Unit.";
      this.orderRequestForm.get('qtyNeeded')?.markAsTouched();
      return false;
    }
    
    // Additional numeric validation for quantity (integers only)
    if (!Number.isInteger(Number(formValue.qtyNeeded)) || Number(formValue.qtyNeeded) <= 0) {
      this.formError = "Please enter only integer value for fields like Quantity,Year,KVA...etc";
      this.orderRequestForm.get('qtyNeeded')?.markAsTouched();
      return false;
    }

    // Order Date validation (cannot be empty)
    if (!formValue.orderDate) {
      this.formError = "Please enter 'Order Date' and resave your Order.";
      this.orderRequestForm.get('orderDate')?.markAsTouched();
      return false;
    }

    return true;
  }

  /**
   * Mark all form fields as touched to trigger validation display
   */
  private markFormGroupTouched(): void {
    Object.keys(this.orderRequestForm.controls).forEach(key => {
      const control = this.orderRequestForm.get(key);
      control?.markAsTouched();
    });
  }

  /**
   * Check if a form field has validation errors and is touched
   */
  isFieldInvalid(fieldName: string): boolean {
    const field = this.orderRequestForm.get(fieldName);
    return !!(field && field.invalid && field.touched);
  }

  /**
   * Get validation error message for a specific field
   */
  getFieldErrorMessage(fieldName: string): string {
    const field = this.orderRequestForm.get(fieldName);
    if (field && field.errors && field.touched) {
      if (field.errors['required']) {
        return `${this.getFieldLabel(fieldName)} is required.`;
      }
      if (field.errors['maxlength']) {
        return `${this.getFieldLabel(fieldName)} cannot exceed ${field.errors['maxlength'].requiredLength} characters.`;
      }
      if (field.errors['min']) {
        return `${this.getFieldLabel(fieldName)} must be greater than or equal to ${field.errors['min'].min}.`;
      }
    }
    return '';
  }

  /**
   * Get display label for form fields (matching legacy labels)
   */
  private getFieldLabel(fieldName: string): string {
    const labels: { [key: string]: string } = {
      orderType: 'Department',
      requester: 'Requester',
      dcgPartNo: 'DCG P/N#',
      manufPartNo: 'Manuf P/N#',
      vendor: 'Vendor',
      qtyNeeded: 'Qty Needed',
      poNumber: 'PO',
      orderDate: 'Order Date',
      arriveDate: 'Arrive Date',
      notes: 'Notes',
      status: 'Status',
      lastModifiedBy: 'Last Modified By'
    };
    return labels[fieldName] || fieldName;
  }

  /**
   * Get counter for attachment list (matches legacy GetCounter function)
   */
  getAttachmentCounter(index: number): number {
    return index + 1;
  }

  /**
   * Cancel form and return to list (matches legacy cancel functionality)
   */
  cancelForm(): void {
    if (confirm('Are you sure you want to cancel? Any unsaved changes will be lost.')) {
      this.resetForm();
    }
  }

  /**
   * Delete order request (matches legacy delete functionality)
   */
  deleteOrderRequest(): void {
    const department = this.orderRequestForm.get('orderType')?.value || 'Order Request';
    
    if (confirm(`Are you sure you want to delete ${department}?\nBy clicking OK you will be directed to Order Request Page.`)) {
      // Implementation would require a delete API endpoint
      // For now, just reset the form
      this.resetForm();
      this.formSuccess = 'Order request deleted successfully';
      setTimeout(() => {
        this.formSuccess = null;
      }, 3000);
    }
  }

  /**
   * Navigate back to the previous page
   */
  goBack(): void {
    this.location.back();
  }
}