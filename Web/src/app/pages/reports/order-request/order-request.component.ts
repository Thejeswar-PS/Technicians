import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Location } from '@angular/common';
import { Router, ActivatedRoute } from '@angular/router';
import { OrderRequestService, PartsTestListResponse, DataTable } from 'src/app/core/services/order-request.service';
import { 
  OrderRequestDto, 
  SaveUpdateOrderRequestRequest, 
  SaveUpdateOrderRequestResponse,
  ORDER_REQUEST_STATUS_OPTIONS,
  ORDER_REQUEST_TYPE_OPTIONS,
  OrderRequestStatusOption,
  OrderRequestTypeOption,
  AutoGeneratedId,
  OrderRequestAttachment,
  UploadedFileInfo
} from 'src/app/core/model/order-request.model';
import { AuthService } from 'src/app/modules/auth/services/auth.service';

@Component({
  selector: 'app-order-request',
  templateUrl: './order-request.component.html',
  styleUrls: ['./order-request.component.scss']
})
export class OrderRequestComponent implements OnInit {
  maxRowIndex: number | null = null;
  isLoading = false;
  error: string | null = null;
  
  // Parts test list related properties
  partsTestData: PartsTestListResponse | null = null;
  isLoadingPartsTest = false;
  partsTestError: string | null = null;
  selectedRowIndex: number = 1;
  selectedSource: string = 'OrderRequest';
  availableSources = ['OrderRequest', 'PartsTest', 'UnitTest', 'Other'];
  
  // Delete functionality
  isDeleting = false;
  deleteError: string | null = null;
  deleteSuccess: string | null = null;

  // Form functionality
  orderRequestForm: FormGroup;
  isFormSubmitting = false;
  formError: string | null = null;
  formSuccess: string | null = null;
  isEditMode = false;
  currentUser: any;
  
  // Auto Generated ID (matching legacy)
  autoGeneratedId: AutoGeneratedId | null = null;
  
  // File attachment functionality
  selectedFiles: File[] = [];
  attachments: OrderRequestAttachment[] = [];
  isUploadingFiles = false;
  
  // File upload restrictions (matching legacy system)
  private readonly ALLOWED_FILE_TYPES = ['jpg', 'gif', 'doc', 'bmp', 'xls', 'png', 'txt', 'xlsx', 'docx', 'pdf', 'jpeg'];
  private readonly MAX_FILE_SIZE_MB = 5;
  private readonly MAX_FILE_SIZE_BYTES = this.MAX_FILE_SIZE_MB * 1024 * 1024;
  
  // Dropdown options (matching legacy)
  statusOptions: OrderRequestStatusOption[] = ORDER_REQUEST_STATUS_OPTIONS;
  departmentOptions: OrderRequestTypeOption[] = ORDER_REQUEST_TYPE_OPTIONS;

  constructor(
    private orderRequestService: OrderRequestService,
    private fb: FormBuilder,
    private authService: AuthService,
    private location: Location,
    private router: Router,
    private route: ActivatedRoute
  ) {
    this.initializeForm();
  }

  ngOnInit(): void {
    this.currentUser = this.authService.currentUserValue;
    
    // Set the current user as the lastModifiedBy after user is loaded
    if (this.currentUser?.userName) {
      this.orderRequestForm.patchValue({
        lastModifiedBy: this.currentUser.userName
      });
    }
    
    // Check for order request data from order request status navigation
    this.route.queryParams.subscribe(params => {
      console.log('Route query params received:', params);
      
      if (params['rowIndex'] || Object.keys(params).length > 0) {
        const rowIndex = parseInt(params['rowIndex'], 10);
        if (!isNaN(rowIndex) && rowIndex > 0) {
          this.selectedRowIndex = rowIndex;
          this.isEditMode = true;
          this.setAutoGeneratedIdFromParams(params, rowIndex);
          
          // Parse date strings if they exist - keep as strings for HTML date inputs
          const orderDate = params['orderDate'] || null;
          const arriveDate = params['arriveDate'] || null;
          const qtyNeeded = params['qtyNeeded'] ? parseInt(params['qtyNeeded'], 10) : null;
          
          // Handle orderType - show empty for std/standard to display placeholder
          const orderType = (params['orderType'] || '').trim().toLowerCase();
          const shouldShowPlaceholder = orderType === 'std' || orderType === 'standard';
          
          // Populate the form with the order request data
          this.orderRequestForm.patchValue({
            rowIndex: rowIndex,
            orderType: shouldShowPlaceholder ? '' : (params['orderType'] || '').trim(),
            requester: (params['requester'] || '').trim(),
            dcgPartNo: (params['dcgPartNo'] || '').trim(),
            manufPartNo: (params['manufPartNo'] || '').trim(),
            qtyNeeded: (qtyNeeded !== null && !isNaN(qtyNeeded)) ? qtyNeeded : null,
            vendor: (params['vendor'] || '').trim(),
            poNumber: (params['poNumber'] || '').trim(),
            orderDate: orderDate,
            arriveDate: arriveDate,
            status: (params['status'] || 'NEW').trim(),
            notes: (params['notes'] || '').trim()
          });

          this.loadOrderRequestDetailsFromApi(rowIndex);
          
          // Debug: Log the values to see what's being set
          console.log('All query params:', params);
          console.log('Form patch values:', {
            orderDate: orderDate,
            arriveDate: arriveDate,
            status: params['status'],
            orderType: params['orderType'],
            requester: params['requester'],
            notes: params['notes']
          });
          console.log('Available status options:', this.statusOptions);
          console.log('Available department options:', this.departmentOptions);
          
          // Add a timeout to check if form values are set correctly
          setTimeout(() => {
            console.log('Form values after patch:', this.orderRequestForm.value);
            console.log('Form control values:');
            console.log('- orderType:', this.orderRequestForm.get('orderType')?.value);
            console.log('- orderDate:', this.orderRequestForm.get('orderDate')?.value);
            console.log('- arriveDate:', this.orderRequestForm.get('arriveDate')?.value);
            console.log('- status:', this.orderRequestForm.get('status')?.value);
            console.log('- requester:', this.orderRequestForm.get('requester')?.value);
            console.log('- notes:', this.orderRequestForm.get('notes')?.value);
          }, 100);
          
          // Load max row index first, then load parts test data
          this.loadMaxOrderRequestRowIndexAndThenLoadData();
          return; // Don't call loadMaxOrderRequestRowIndex() again
        }
      }
      // If no rowIndex parameter, load normally
      this.generateAutoId();
      this.loadMaxOrderRequestRowIndex();
    });
  }

  private loadOrderRequestDetailsFromApi(rowIndex: number): void {
    this.orderRequestService.getPartsTestList(rowIndex, 'OrderRequest').subscribe({
      next: (data: PartsTestListResponse) => {
        const dataAny = data as any;
        const table = data?.Tables?.[0];
        const row = table?.Rows?.[0] || dataAny?.tables?.[0]?.rows?.[0];
        if (!row) {
          console.warn('Order Request details not found in API response.', data);
          return;
        }

        this.orderRequestForm.patchValue({
          orderType: (row.OrderType || row.orderType || '').toString().trim(),
          requester: (row.Requester || row.requester || '').toString().trim(),
          dcgPartNo: (row.DCGPartNo || row.dcgPartNo || '').toString().trim(),
          manufPartNo: (row.ManufPartNo || row.manufPartNo || '').toString().trim(),
          qtyNeeded: row.QtyNeeded ?? row.qtyNeeded ?? null,
          vendor: (row.Vendor || row.vendor || '').toString().trim(),
          poNumber: (row.PONumber || row.poNumber || '').toString().trim(),
          orderDate: row.OrderDate ? new Date(row.OrderDate).toISOString().split('T')[0] : this.orderRequestForm.get('orderDate')?.value,
          arriveDate: row.ArriveDate ? new Date(row.ArriveDate).toISOString().split('T')[0] : this.orderRequestForm.get('arriveDate')?.value,
          status: (row.Status || row.status || this.orderRequestForm.get('status')?.value || 'NEW').toString().trim(),
          notes: (row.Notes || row.notes || '').toString().trim()
        });

        console.log('Order Request details loaded from API:', row);
      },
      error: (error) => {
        console.error('Error loading order request details:', error);
      }
    });
  }

  /**
   * Initialize the reactive form (matching legacy form fields)
   */
  initializeForm(): void {
    this.orderRequestForm = this.fb.group({
      rowIndex: [0],
      orderType: [''], // Department - optional for easier saving
      requester: [''], // Requester - optional for easier saving
      dcgPartNo: [''], // DCG P/N# - optional
      manufPartNo: [''], // Manuf P/N# - optional for easier saving
      vendor: [''], // Vendor - optional
      qtyNeeded: [null], // Qty Needed - optional for easier saving
      poNumber: [''], // PO - optional
      orderDate: [null], // Order Date - optional for easier saving
      arriveDate: [null], // Arrive Date - optional
      notes: [''], // Notes - optional
      status: ['NEW'], // Default to 'NEW' status - optional
      lastModifiedBy: ['']
    });

    // Set the current user as the lastModifiedBy default value
    if (this.currentUser?.userName) {
      this.orderRequestForm.patchValue({
        lastModifiedBy: this.currentUser.userName
      });
    }
  }

  /**
   * Generate auto ID in format YYYY-M-D-SEQ (matching legacy)
   */
  generateAutoId(): void {
    const now = new Date();
    
    // Get the next sequence number from database
    this.orderRequestService.getMaxOrderRequestRowIndex().subscribe({
      next: (maxRowIndex: number) => {
        const nextSequence = (maxRowIndex + 1).toString();
        
        this.autoGeneratedId = {
          year: now.getFullYear().toString(),
          month: (now.getMonth() + 1).toString(),
          day: now.getDate().toString(),
          id: nextSequence // Database-driven sequence number
        };
        
        // Console log for UI-generated auto ID with database sequence
        console.log('UI Generated Auto ID (DB Sequence):', `${this.autoGeneratedId.year}-${this.autoGeneratedId.month}-${this.autoGeneratedId.day}-${this.autoGeneratedId.id}`);
        console.log('Next DB Sequence Number:', nextSequence);
      },
      error: (error) => {
        console.error('Error getting next sequence from database:', error);
        // Fallback to timestamp-based sequence if database call fails
        const fallbackSequence = Date.now().toString().slice(-2);
        
        this.autoGeneratedId = {
          year: now.getFullYear().toString(),
          month: (now.getMonth() + 1).toString(),
          day: now.getDate().toString(),
          id: fallbackSequence
        };
        
        console.log('UI Generated Auto ID (Fallback):', `${this.autoGeneratedId.year}-${this.autoGeneratedId.month}-${this.autoGeneratedId.day}-${this.autoGeneratedId.id}`);
      }
    });
  }

  private setAutoGeneratedIdFromParams(params: { [key: string]: any }, rowIndex: number): void {
    const createdOnParam = params['createdOn'] || params['CreatedOn'] || null;
    const createdOnDate = createdOnParam ? new Date(createdOnParam) : null;
    const useDate = createdOnDate && !isNaN(createdOnDate.getTime()) ? createdOnDate : new Date();

    this.autoGeneratedId = {
      year: useDate.getFullYear().toString(),
      month: (useDate.getMonth() + 1).toString(),
      day: useDate.getDate().toString(),
      id: rowIndex.toString()
    };
  }

  /**
   * Load the maximum Order Request row index
   */
  loadMaxOrderRequestRowIndex(): void {
    this.isLoading = true;
    this.error = null;

    this.orderRequestService.getMaxOrderRequestRowIndex().subscribe({
      next: (data: number) => {
        this.maxRowIndex = data;
        this.selectedRowIndex = Math.min(1, data || 1); // Set default row index
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading max order request row index:', error);
        this.error = 'Failed to load Order Request data. Please try again.';
        this.isLoading = false;
      }
    });
  }

  /**
   * Load max row index first, then load parts test data for the selected row
   */
  loadMaxOrderRequestRowIndexAndThenLoadData(): void {
    this.isLoading = true;
    this.error = null;

    this.orderRequestService.getMaxOrderRequestRowIndex().subscribe({
      next: (data: number) => {
        this.maxRowIndex = data;
        this.isLoading = false;
        
        // Now that we have maxRowIndex, we can safely load the parts test data
        this.loadPartsTestList();
      },
      error: (error) => {
        console.error('Error loading max order request row index:', error);
        this.error = 'Failed to load Order Request data. Please try again.';
        this.isLoading = false;
      }
    });
  }

  /**
   * Load parts test list data
   */
  loadPartsTestList(): void {
    if (this.selectedRowIndex < 1) {
      this.partsTestError = 'Please enter a valid row index (minimum 1)';
      return;
    }

    if (this.maxRowIndex && this.selectedRowIndex > this.maxRowIndex) {
      this.partsTestError = `Row index cannot exceed maximum value of ${this.maxRowIndex}`;
      return;
    }

    this.isLoadingPartsTest = true;
    this.partsTestError = null;
    this.partsTestData = null;

    this.orderRequestService.getPartsTestList(this.selectedRowIndex, this.selectedSource).subscribe({
      next: (data: PartsTestListResponse) => {
        this.partsTestData = data;
        this.isLoadingPartsTest = false;
        
        if (data.ErrorMessage) {
          this.partsTestError = data.ErrorMessage;
        }
      },
      error: (error) => {
        console.error('Error loading parts test list:', error);
        this.partsTestError = 'Failed to load Parts Test List data. Please try again.';
        this.isLoadingPartsTest = false;
      }
    });
  }

  /**
   * Refresh the data
   */
  refreshData(): void {
    this.loadMaxOrderRequestRowIndex();
    if (this.partsTestData) {
      this.loadPartsTestList();
    }
  }

  /**
   * Clear parts test data
   */
  clearPartsTestData(): void {
    this.partsTestData = null;
    this.partsTestError = null;
    this.deleteError = null;
    this.deleteSuccess = null;
  }

  /**
   * Delete parts test list data
   */
  deletePartsTestList(): void {
    if (this.selectedRowIndex < 1) {
      this.deleteError = 'Please enter a valid row index (minimum 1)';
      return;
    }

    if (this.maxRowIndex && this.selectedRowIndex > this.maxRowIndex) {
      this.deleteError = `Row index cannot exceed maximum value of ${this.maxRowIndex}`;
      return;
    }

    // Confirm deletion
    if (!confirm(`Are you sure you want to delete parts test list for Row Index ${this.selectedRowIndex} and Source ${this.selectedSource}?`)) {
      return;
    }

    this.isDeleting = true;
    this.deleteError = null;
    this.deleteSuccess = null;

    this.orderRequestService.deletePartsTestList(this.selectedRowIndex, this.selectedSource).subscribe({
      next: (response: {message: string}) => {
        this.deleteSuccess = response.message || 'Parts test list deleted successfully';
        this.isDeleting = false;
        
        // Clear current data after successful deletion
        this.partsTestData = null;
        
        // Auto-hide success message after 5 seconds
        setTimeout(() => {
          this.deleteSuccess = null;
        }, 5000);
      },
      error: (error) => {
        console.error('Error deleting parts test list:', error);
        this.deleteError = 'Failed to delete Parts Test List data. Please try again.';
        this.isDeleting = false;
      }
    });
  }

  /**
   * Check if a table has data
   */
  hasTableData(table: DataTable): boolean {
    return table && table.Rows && table.Rows.length > 0;
  }

  /**
   * Get display value for table cell
   */
  getCellValue(value: any): string {
    if (value === null || value === undefined) {
      return '';
    }
    return value.toString();
  }

  /**
   * Get current date and time as a formatted string
   */
  getCurrentDateTime(): string {
    return new Date().toLocaleString();
  }

  /**
   * Reset the form to create a new order request
   */
  resetForm(): void {
    this.isEditMode = false;
    this.formError = null;
    this.formSuccess = null;
    this.selectedFiles = [];
    this.attachments = [];
    this.generateAutoId(); // Generate new auto ID
    this.orderRequestForm.reset({
      rowIndex: 0,
      status: 'NEW',
      lastModifiedBy: this.currentUser?.userName || ''
    });
  }

  /**
   * Handle file selection for attachments (with validation matching legacy system)
   */
  onFileSelected(event: any): void {
    const files: FileList = event.target.files;
    if (files && files.length > 0) {
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        // Validate file type
        if (!this.isValidFileType(file.name)) {
          this.formError = `Invalid file format. File must be of format ${this.ALLOWED_FILE_TYPES.join(',')}`;
          continue;
        }
        
        // Validate file size
        if (file.size > this.MAX_FILE_SIZE_BYTES) {
          this.formError = `File size exceeds ${this.MAX_FILE_SIZE_MB}MB limit. Please select a smaller file.`;
          continue;
        }
        
        // Check for duplicates
        if (!this.selectedFiles.find(f => f.name === file.name)) {
          this.selectedFiles.push(file);
          this.attachments.push({
            name: file.name,
            creationTime: new Date(),
            fullName: file.name,
            size: file.size
          });
          
          // Clear any previous errors if file is valid
          this.formError = null;
        }
      }
    }
    
    // Reset the input to allow selecting the same file again if needed
    event.target.value = '';
  }

  /**
   * Remove an attachment
   */
  removeAttachment(index: number): void {
    this.selectedFiles.splice(index, 1);
    this.attachments.splice(index, 1);
  }

  /**
   * Validate file type (matching legacy IsValidFile method)
   */
  private isValidFileType(fileName: string): boolean {
    const fileExtension = this.getFileExtension(fileName);
    return this.ALLOWED_FILE_TYPES.some(allowedType => 
      allowedType.toLowerCase() === fileExtension.toLowerCase()
    );
  }

  /**
   * Get file extension (matching legacy GetFileExtension method)
   */
  private getFileExtension(fileName: string): string {
    const lastDotIndex = fileName.lastIndexOf('.');
    if (lastDotIndex === -1) {
      return '';
    }
    return fileName.substring(lastDotIndex + 1);
  }

  /**
   * Get file size in readable format
   */
  getFileSizeFormatted(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * Load an existing order request for editing (placeholder for future implementation)
   */
  loadOrderRequestForEdit(rowIndex: number): void {
    // This would require a new API endpoint to get order request by row index
    // For now, we'll just set the form to edit mode and populate the row index
    this.isEditMode = true;
    this.orderRequestForm.patchValue({
      rowIndex: rowIndex
    });
  }

  /**
   * Save or update the order request (with validation matching legacy)
   */
  saveOrderRequest(): void {
    // Custom validation matching legacy JavaScript validation
    if (!this.validateForm()) {
      return;
    }

    this.isFormSubmitting = true;
    this.isLoading = true;
    this.formError = null;
    this.formSuccess = null;

    const formValue = this.orderRequestForm.value;
    
    // Convert form data to the API request format
    const orderRequest: SaveUpdateOrderRequestRequest = {
      rowIndex: formValue.rowIndex || 0,
      orderType: formValue.orderType || null,
      requester: formValue.requester || null,
      dcgPartNo: formValue.dcgPartNo || null,
      manufPartNo: formValue.manufPartNo || null,
      vendor: formValue.vendor || null,
      qtyNeeded: formValue.qtyNeeded || null,
      poNumber: formValue.poNumber || null,
      orderDate: formValue.orderDate || null,
      arriveDate: formValue.arriveDate || null,
      notes: formValue.notes || null,
      status: formValue.status || null,
      lastModifiedBy: formValue.lastModifiedBy || this.currentUser?.userName || 'System'
    };

    // Check if we have files to upload
    if (this.selectedFiles.length > 0) {
      // Use the file upload endpoint
      this.orderRequestService.saveUpdateOrderRequestWithFiles(orderRequest, this.selectedFiles).subscribe({
        next: (response: any) => {
          let successMessage = response.message || 'Order request saved successfully';
          
          // Handle file upload results from new backend structure
          if (response.fileResults && response.fileResults.length > 0) {
            const successfulUploads = response.fileResults.filter((f: any) => f.success === true).length;
            const failedUploads = response.fileResults.filter((f: any) => f.success === false).length;
            
            if (failedUploads > 0) {
              // Show failed uploads in error message
              const failedFiles = response.fileResults.filter((f: any) => f.success === false);
              const errorMessages = failedFiles.map((f: any) => `${f.fileName}: ${f.errorMessage}`).join('; ');
              this.formError = `Some files failed to upload: ${errorMessages}`;
            }
            
            // Log file details for debugging
            console.log('File upload results:', response.fileResults);
          }
          
          this.formSuccess = successMessage;
          this.isFormSubmitting = false;
          this.isLoading = false;
          
          // Update the form with the returned row index if it was a new record
          if (orderRequest.rowIndex === 0) {
            this.orderRequestForm.patchValue({
              rowIndex: response.rowIndex
            });
            this.isEditMode = true;
            
            // Console log for database-returned ID
            console.log('Database Generated Row Index ID:', response.rowIndex);
          }
          
          // Clear selected files after successful upload
          this.selectedFiles = [];
          this.attachments = [];
          
          // Refresh the max row index
          this.loadMaxOrderRequestRowIndex();
          
          // Auto-hide success message after 5 seconds
          setTimeout(() => {
            this.formSuccess = null;
          }, 5000);
        },
        error: (error) => {
          console.error('Error saving order request with files:', error);
          this.formError = error.error?.message || 'Failed to save order request with files. Please try again.';
          this.isFormSubmitting = false;
          this.isLoading = false;
        }
      });
    } else {
      // No files, use the regular endpoint
      this.orderRequestService.saveUpdateOrderRequest(orderRequest).subscribe({
        next: (response: any) => {
          this.formSuccess = response.message || 'Order request saved successfully';
          this.isFormSubmitting = false;
          this.isLoading = false;
          
          // Update the form with the returned row index if it was a new record
          if (orderRequest.rowIndex === 0) {
            this.orderRequestForm.patchValue({
              rowIndex: response.rowIndex
            });
            this.isEditMode = true;
            
            // Console log for database-returned ID
            console.log('Database Generated Row Index ID:', response.rowIndex);
          }
          
          // Refresh the max row index
          this.loadMaxOrderRequestRowIndex();
          
          // Auto-hide success message after 5 seconds
          setTimeout(() => {
            this.formSuccess = null;
          }, 5000);
        },
        error: (error) => {
          console.error('Error saving order request:', error);
          this.formError = error.error?.message || 'Failed to save order request. Please try again.';
          this.isFormSubmitting = false;
          this.isLoading = false;
        }
      });
    }
  }

  /**
   * Custom validation matching legacy JavaScript validation
   */
  private validateForm(): boolean {
    const formValue = this.orderRequestForm.value;

    // Department validation (matches legacy - must not be "PS" or empty)
    if (!formValue.orderType || formValue.orderType === '' || formValue.orderType === 'PS') {
      this.formError = "Please select 'Type' and resave your entry.";
      this.orderRequestForm.get('orderType')?.markAsTouched();
      return false;
    }

    // Requester validation (cannot be empty or null)
    if (!formValue.requester || formValue.requester.trim() === '') {
      this.formError = "Please enter 'Requester' and resave your Unit.";
      this.orderRequestForm.get('requester')?.markAsTouched();
      return false;
    }

    // Manufacturer Part No validation (cannot be empty or null)
    if (!formValue.manufPartNo || formValue.manufPartNo.trim() === '') {
      this.formError = "Please enter 'Manuf PNo' and resave your Unit.";
      this.orderRequestForm.get('manufPartNo')?.markAsTouched();
      return false;
    }

    // Quantity validation (cannot be empty and must be numeric integers only)
    if (!formValue.qtyNeeded) {
      this.formError = "Please enter 'Quantity' and resave your Unit.";
      this.orderRequestForm.get('qtyNeeded')?.markAsTouched();
      return false;
    }
    
    // Additional numeric validation for quantity (integers only)
    if (!Number.isInteger(Number(formValue.qtyNeeded)) || Number(formValue.qtyNeeded) <= 0) {
      this.formError = "Please enter only integer value for fields like Quantity,Year,KVA...etc";
      this.orderRequestForm.get('qtyNeeded')?.markAsTouched();
      return false;
    }

    // Order Date validation (cannot be empty)
    if (!formValue.orderDate) {
      this.formError = "Please enter 'Order Date' and resave your Order.";
      this.orderRequestForm.get('orderDate')?.markAsTouched();
      return false;
    }

    return true;
  }

  /**
   * Mark all form fields as touched to trigger validation display
   */
  private markFormGroupTouched(): void {
    Object.keys(this.orderRequestForm.controls).forEach(key => {
      const control = this.orderRequestForm.get(key);
      control?.markAsTouched();
    });
  }

  /**
   * Check if a form field has validation errors and is touched
   */
  isFieldInvalid(fieldName: string): boolean {
    const field = this.orderRequestForm.get(fieldName);
    return !!(field && field.invalid && field.touched);
  }

  /**
   * Get validation error message for a specific field
   */
  getFieldErrorMessage(fieldName: string): string {
    const field = this.orderRequestForm.get(fieldName);
    if (field && field.errors && field.touched) {
      if (field.errors['required']) {
        return `${this.getFieldLabel(fieldName)} is required.`;
      }
      if (field.errors['maxlength']) {
        return `${this.getFieldLabel(fieldName)} cannot exceed ${field.errors['maxlength'].requiredLength} characters.`;
      }
      if (field.errors['min']) {
        return `${this.getFieldLabel(fieldName)} must be greater than or equal to ${field.errors['min'].min}.`;
      }
    }
    return '';
  }

  /**
   * Get display label for form fields (matching legacy labels)
   */
  private getFieldLabel(fieldName: string): string {
    const labels: { [key: string]: string } = {
      orderType: 'Department',
      requester: 'Requester',
      dcgPartNo: 'DCG P/N#',
      manufPartNo: 'Manuf P/N#',
      vendor: 'Vendor',
      qtyNeeded: 'Qty Needed',
      poNumber: 'PO',
      orderDate: 'Order Date',
      arriveDate: 'Arrive Date',
      notes: 'Notes',
      status: 'Status',
      lastModifiedBy: 'Last Modified By'
    };
    return labels[fieldName] || fieldName;
  }

  /**
   * Get counter for attachment list (matches legacy GetCounter function)
   */
  getAttachmentCounter(index: number): number {
    return index + 1;
  }

  /**
   * Cancel form and return to list (matches legacy cancel functionality)
   */
  cancelForm(): void {
    if (confirm('Are you sure you want to cancel? Any unsaved changes will be lost.')) {
      this.resetForm();
    }
  }

  /**
   * Delete order request (matches legacy delete functionality)
   */
  deleteOrderRequest(): void {
    const department = this.orderRequestForm.get('orderType')?.value || 'Order Request';
    const rowIndex = this.orderRequestForm.get('rowIndex')?.value;
    
    // Validate that we have a valid row index to delete
    if (!rowIndex || rowIndex <= 0) {
      this.formError = 'Cannot delete: No valid order request selected or saved.';
      return;
    }
    
    if (confirm(`Are you sure you want to delete ${department}?\nThis action cannot be undone.`)) {
      this.isFormSubmitting = true;
      this.formError = null;
      this.formSuccess = null;
      
      this.orderRequestService.deleteOrderRequest(rowIndex).subscribe({
        next: (response: any) => {
          this.formSuccess = response.message || 'Order request deleted successfully';
          this.isFormSubmitting = false;
          
          // Reset form after successful deletion
          this.resetForm();
          
          // Navigate back to the order request status page after a brief delay
          setTimeout(() => {
            this.router.navigate(['/reports/order-request-status']);
          }, 2000);
        },
        error: (error) => {
          console.error('Error deleting order request:', error);
          
          // Handle different error responses
          let errorMessage = 'Failed to delete order request. Please try again.';
          if (error.status === 404) {
            errorMessage = 'Order request not found or already deleted.';
          } else if (error.status === 400) {
            errorMessage = error.error?.message || 'Invalid request. Please check the data.';
          } else if (error.error?.message) {
            errorMessage = error.error.message;
          }
          
          this.formError = errorMessage;
          this.isFormSubmitting = false;
        }
      });
    }
  }

  /**
   * Navigate back to Order Request Status page
   */
  goBack(): void {
    this.router.navigate(['/reports/order-request-status']);
  }

  /**
   * Navigate to Order Request Status page
   */
  goToOrderRequestStatus(): void {
    this.router.navigate(['/reports/order-request-status']);
  }

  /**
   * Handle keypress events for numeric input - only allow numbers
   */
  onNumberKeyPress(event: KeyboardEvent): boolean {
    const charCode = event.which || event.keyCode;
    const charStr = String.fromCharCode(charCode);
    
    // Allow: backspace, delete, tab, escape, enter
    if ([8, 9, 27, 13, 46].indexOf(charCode) !== -1 ||
        // Allow: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
        (charCode === 65 && event.ctrlKey === true) ||
        (charCode === 67 && event.ctrlKey === true) ||
        (charCode === 86 && event.ctrlKey === true) ||
        (charCode === 88 && event.ctrlKey === true)) {
      return true;
    }
    
    // Allow only numbers (0-9)
    if (!/^[0-9]$/.test(charStr)) {
      event.preventDefault();
      return false;
    }
    
    return true;
  }

  /**
   * Handle paste events for numeric input - only allow numbers
   */
  onNumberPaste(event: ClipboardEvent): void {
    const pastedData = event.clipboardData?.getData('text') || '';
    
    // Check if pasted data contains only numbers
    if (!/^[0-9]+$/.test(pastedData)) {
      event.preventDefault();
    }
  }
}